<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title></title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap-3.0.0-wip.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome-ie7.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="brand" href="http://github.com/jsoverson/plato">Plato on Github</a>
    <ul class="nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>dragdrop.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="span6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"></i></a></h2>
      <p class="stat">63.13</p>
    </div>
    <div class="span6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC"></i></h2>
      <p class="stat">321</p>
    </div>
  </div>
  <div class="row historical">
    <div class="span6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="span6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="span6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty"></i></a></h2>
      <p class="stat">41.81</p>
    </div>
    <div class="span6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs"></i></a></h2>
      <p class="stat">1.97</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="span6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="span6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="span12">'use strict';

const DragDropManager = (function() {

  /*
   * It defines the time (in ms) while checking limits is disabled
   */
  var CHECK_LIMITS_DELAY = 700;

  /*
   * It defines the time (in ms) between consecutive rearranges
   */
  var REARRANGE_DELAY = 50;

  /*
   * Drop feature is disabled (in the borders of the icongrid)
   */
  var isDisabledDrop = false;

  var isDockDisabled = false;

  /*
   * Checking limits is disabled
   */
  var isDisabledCheckingLimits = false;

  /*
   * Timeout of the checking limits function
   */
  var disabledCheckingLimitsTimeout = null;

  var draggableIcon, previousOverlapIcon, overlapingTimeout, overlapElem,
      originElem;

  var pageHelper = GridManager.pageHelper;

  var dirCtrl, limitY, overlapingDock;

  var currentEvent = {}, startEvent = {};

  /*
   * Sets the isTranslatingPages variable
   *
   * @param {Boolean} the value
   */
  function setDisabledCheckingLimits(value) {
    isDisabledCheckingLimits = value;
    if (value) {
      disabledCheckingLimitsTimeout = setTimeout(
        function dg_disabledCheckingLimitsTimeout() {
          isDisabledCheckingLimits = false;
          checkLimits();
        }, CHECK_LIMITS_DELAY);
    }
  }

  var transitioning = false;

  function onNavigationEnd() {
    transitioning = false;
  }

  function overDock() {
    if (isDockDisabled) {
      if (!overlapingDock) {
        // If we are coming from grid -> the drop action is disabled
        draggableIcon.addClassToDragElement('overDock');
        overlapingDock = isDisabledDrop = true;
      }

      return;
    }

    if (!overlapingDock) {
      // I've just entered
      draggableIcon.addClassToDragElement('overDock');
      DockManager.page.appendIcon(draggableIcon);
      drop(DockManager.page);
      previousOverlapIcon = overlapElem;
    }

    if (dirCtrl.limitNext(currentEvent.x)) {
      DockManager.goNextSet();
    } else if (dirCtrl.limitPrev(currentEvent.x)) {
      DockManager.goPreviousSet();
    }

    overlapingDock = true;
  }

  function overIconGrid() {
    if (transitioning) {
      isDisabledDrop = true;
      return;
    }

    isDisabledDrop = false;
    var currentX = currentEvent.x;
    var curPageObj = pageHelper.getCurrent();

    if (overlapingDock) {
      draggableIcon.removeClassToDragElement('overDock');
      overlapingDock = false;
      curPageObj.appendIconVisible(draggableIcon);
    } else if (!isDisabledCheckingLimits) {
      if (dirCtrl.limitNext(currentX)) {
        isDisabledDrop = true;

        if (pageHelper.getCurrentPageNumber() <
            pageHelper.getTotalPagesNumber() - 1) {
          pageHelper.getNext().appendIconVisible(draggableIcon);
        } else if (curPageObj.getNumIcons() > 1) {
          // New page if there are two or more icons
          pageHelper.addPage([draggableIcon]);
        }

        setDisabledCheckingLimits(true);
        if (pageHelper.getNext()) {
          GridManager.goToNextPage(onNavigationEnd);
          transitioning = true;
        }
      } else if (pageHelper.getCurrentPageNumber() > GridManager.landingPage + 1
                 && dirCtrl.limitPrev(currentX)) {
        isDisabledDrop = true;

        pageHelper.getPrevious().appendIconVisible(draggableIcon);
        setDisabledCheckingLimits(true);
        transitioning = true;
        GridManager.goToPreviousPage(onNavigationEnd);
      }
    }
  }

  /*
   * Detects when users are touching on the limits of a page during
   * the dragging. So we can change the current page and navigate
   * to prev/next page depending on the position.
   * Furthermore, this method is in charge of creating a new page when
   * it's needed
   */
  function checkLimits() {
    if (currentEvent.y >= limitY) {
      overDock(overlapElem);
    } else {
      overIconGrid();
    }
  }

  /*
   * This method is executed when dragging starts
   *
   * {Object} This is the DOMElement which was tapped and hold
   */
  function onStart(elem) {
    overlapElem = originElem = elem;
    draggableIcon = GridManager.getIcon(elem.dataset);
    draggableIcon.onDragStart(startEvent.x, startEvent.y);
    if (overlapingDock) {
      draggableIcon.addClassToDragElement('overDock');
    } else if (DockManager.isFull()) {
      isDockDisabled = true;
    }
  }

  /*
   * This method is invoked when dragging is finished. It checks if
   * there is overflow or not in a page and removes the last page when
   * is empty
   */
  function stop(callback) {
    clearTimeout(disabledCheckingLimitsTimeout);
    isDisabledCheckingLimits = false;
    isDisabledDrop = false;
    transitioning = false;

    var page = getPage();
    if (page.ready) {
      draggableIcon.onDragStop(callback);
    } else {
      // Probably users release the draggable icon before re-arranged
      page.onReArranged = function fn_ready() {
        delete page.onReArranged;
        draggableIcon.onDragStop(callback);
      };
    }
  }

  function drop(page) {
    var classList = overlapElem.classList;
    if (classList.contains('icon')) {
      var overlapIcon = GridManager.getIcon(overlapElem.dataset);
      page.drop(draggableIcon, overlapIcon);
    } else if (classList.contains('dockWrapper')) {
      var firstIcon = page.getFirstIcon();
      if (currentEvent.x < firstIcon.getLeft()) {
        if (draggableIcon !== firstIcon) {
          page.drop(draggableIcon, firstIcon);
        }
      } else {
        var lastIcon = page.getLastIcon();
        if (draggableIcon !== lastIcon) {
          page.drop(draggableIcon, lastIcon);
        }
      }
    }
    previousOverlapIcon = undefined;
  }

  /*
   * It's performed when the draggable element is moving
   *
   * @param {Object} DOMElement behind draggable icon
   */
  function onMove(evt) {
    var x = currentEvent.x = evt.touches[0].pageX;
    var y = currentEvent.y = evt.touches[0].pageY;

    draggableIcon.onDragMove(x, y);

    var page = getPage();
    if (!page.ready) {
      return;
    }

    var newOverlapElem = overlapElem;
    if (overlapElem.classList.contains('page')) {
      // We are on the grid but not icon
      newOverlapElem = document.elementFromPoint(x, y);
    } else {
      // Avoid calling document.elementFromPoint if we are over the same icon
      var rectObject = overlapElem.getBoundingClientRect();
      if (overlapElem.classList.contains('page') ||
          x < rectObject.left || x > rectObject.right ||
          y < rectObject.top || y > rectObject.bottom) {
        newOverlapElem = document.elementFromPoint(x, y);
      }
    }

    // elementFromPoint can return null in some situations, most notably when
    // the user's finger goes below the dock, on the soft buttons
    if (newOverlapElem) {
      overlapElem = newOverlapElem;
      handleMove(page, x, y);
    }
  }

  function handleMove(page, x, y) {
    var classList = overlapElem.classList;
    if (!classList) {
      clearTimeout(overlapingTimeout);
      return;
    }

    checkLimits(overlapElem);
    if (isDisabledDrop) {
      clearTimeout(overlapingTimeout);
      return;
    }

    if (previousOverlapIcon !== overlapElem) {
      clearTimeout(overlapingTimeout);
      if (classList.contains('page')) {
        var lastIcon = page.getLastIcon();
        if (y > lastIcon.getTop() && draggableIcon !== lastIcon) {
          page.drop(draggableIcon, lastIcon);
        }
      } else {
        overlapingTimeout = setTimeout(drop, REARRANGE_DELAY, page);
      }
    }

    previousOverlapIcon = overlapElem;
  }

  function onEnd(evt) {
    // No multi-touch
    if (evt.target !== originElem)
      return;

    clearTimeout(overlapingTimeout);
    window.removeEventListener('touchmove', onMove);
    window.removeEventListener('touchend', onEnd);
    stop(function dg_stop() {
      GridManager.onDragStop();
      DockManager.onDragStop();
    });
  }

  function getPage() {
    return overlapingDock ? DockManager.page : pageHelper.getCurrent();
  }

  return {

    /*
     * Initializes the drag & drop manager
     */
    init: function ddm_init() {
      dirCtrl = GridManager.dirCtrl;
      limitY = window.innerHeight -
               document.querySelector('#footer').offsetHeight;
    },

    /*
     * Starts drag & drop
     *
     * @param {Object} DOM event
     */
    start: function ddm_start(evt, initCoords) {
      window.addEventListener('touchmove', onMove);
      window.addEventListener('touchend', onEnd);
      GridManager.onDragStart();
      DockManager.onDragStart();
      startEvent = initCoords;
      isDockDisabled = false;
      overlapingDock = (initCoords.y >= limitY) ? true : false;
      onStart(evt.target.className === 'options' ? evt.target.parentNode :
                                                   evt.target);
    }
  };
}());</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
