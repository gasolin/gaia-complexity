<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title></title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap-3.0.0-wip.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome-ie7.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="brand" href="http://github.com/jsoverson/plato">Plato on Github</a>
    <ul class="nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>search.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="span6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"></i></a></h2>
      <p class="stat">65.58</p>
    </div>
    <div class="span6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC"></i></h2>
      <p class="stat">446</p>
    </div>
  </div>
  <div class="row historical">
    <div class="span6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="span6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="span6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty"></i></a></h2>
      <p class="stat">52.33</p>
    </div>
    <div class="span6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs"></i></a></h2>
      <p class="stat">3.59</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="span6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="span6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="span12">'use strict';

var contacts = window.contacts || {};

contacts.Search = (function() {
  var favoriteGroup,
      inSearchMode = false,
      conctactsListView,
      searchView,
      CONTACTS_SELECTOR = ".contact-item:not([data-uuid='#id#'])," +
                              ".block-item:not([data-uuid='#uid#'])",
      list,
      searchBox,
      searchList,
      searchNoResult,
      searchProgress,
      contactNodes = null,
      // On the steady state holds the list result of the current search
      searchableNodes = null,
      currentTextToSearch = '',
      prevTextToSearch = '',
      // Pointer to the nodes which are currently on the result list
      currentSet = {},
      searchTextCache = {},
      canReuseSearchables = false,
      blurList = false,
      theClones = {},
      CHUNK_SIZE = 10,
      // These values might change for other form factors
      SEARCH_PAGE_SIZE = 7,
      // Search result will not be showing more than HARD_LIMIT contacts
      HARD_LIMIT = 25,
      emptySearch = true,
      remainingPending = true,
      imgLoader,
      searchEnabled = false;

  var onLoad = function onLoad() {
    searchView = document.getElementById('search-view');
    searchList = document.getElementById('search-list');
  };

  onLoad();

  var init = function load(_conctactsListView, _groupFavorites, _clickHandler,
                           defaultEnabled) {
    conctactsListView = _conctactsListView;
    favoriteGroup = _groupFavorites;

    if (typeof _clickHandler === 'function') {
      searchList.addEventListener('click', _clickHandler);
    }

    if (defaultEnabled)
      searchEnabled = true;
  };

  var initialized = false;

  var doInit = function doInit() {
    if (initialized) {
      return;
    }

    initialized = true;
    searchBox = document.getElementById('search-contact');
    var resetButton = searchBox.nextElementSibling;
    resetButton.addEventListener('ontouchstart' in window ? 'touchstart' :
                                 'mousedown', function() {
      searchBox.value = '';
      searchBox.focus();
      resetState();
      window.setTimeout(fillInitialSearchPage, 0);
    });

    searchList.parentNode.addEventListener('touchstart', function() {
      blurList = true;
    });
    searchNoResult = document.getElementById('no-result');
    searchProgress = document.getElementById('search-progress');
    list = document.getElementById('groups-list');
    searchBox.addEventListener('blur', function() {
      window.setTimeout(onSearchBlur, 0);
    });

    searchBox.addEventListener('focus', function() {
      blurList = false;
    });

    imgLoader = new ImageLoader('#groups-list-search', 'li');
    LazyLoader.load(['/contacts/js/fb_resolver.js'], function() {
      imgLoader.setResolver(fb.resolver);
    });
  };

  //Search mode instructions
  var exitSearchMode = function exitSearchMode(evt) {
    evt.preventDefault();
    searchView.classList.remove('insearchmode');

    window.setTimeout(function exit_search() {
      hideProgressResults();

      searchBox.value = '';
      // Resetting state
      contactNodes = null;
      searchTextCache = {};
      resetState();

      inSearchMode = false;
    }, 0);

    window.removeEventListener('input', onInput);
  };

  function resetState() {
    prevTextToSearch = '';
    currentTextToSearch = '';
    searchableNodes = null;
    canReuseSearchables = false;
    currentSet = {};
    // We don't know if the user will launch a new search later
    theClones = {};
    utils.dom.removeChildNodes(searchList);
    emptySearch = true;
    remainingPending = true;
  }

  function addRemainingResults(nodes, from) {
    if (remainingPending !== true) {
      return;
    }

    var fragment = document.createDocumentFragment();

    for (var i = from; i < HARD_LIMIT && i < nodes.length; i++) {
      var node = nodes[i].node;
      var clon = getClone(node);
      fragment.appendChild(clon);
      currentSet[node.dataset.uuid] = clon;
    }

    if (fragment.hasChildNodes()) {
      searchList.appendChild(fragment);
      imgLoader.reload();
    }

    remainingPending = false;
  }

  function onSearchBlur(e) {
    if (canReuseSearchables && searchableNodes &&
        searchView.classList.contains('insearchmode') && blurList) {
      // All the searchable nodes have to be added
      addRemainingResults(searchableNodes, SEARCH_PAGE_SIZE);
    }
    else if (emptySearch === true && remainingPending === true) {
      var lastNode = searchList.querySelector('li:last-child');
      if (lastNode) {
        var lastNodeUid = lastNode.dataset.uuid;
        var startNode = getNextContactNode(conctactsListView.querySelector
                            ('[data-uuid="' + lastNodeUid + '"]'));
        fillIdentityResults(startNode, HARD_LIMIT - SEARCH_PAGE_SIZE);
        remainingPending = false;

        imgLoader.reload();
      }
    }
  }

  function fillIdentityResults(startNode, number) {
    var fragment = document.createDocumentFragment();

    var contact = startNode;
    for (var i = 0; i < number && contact; i++) {
      var clonedNode = getClone(contact);
      fragment.appendChild(clonedNode);
      currentSet[contact.dataset.uuid] = clonedNode;
      contact = getNextContactNode(contact);
    }

    if (fragment.hasChildNodes()) {
      searchList.appendChild(fragment);
    }
  }

  // Traverses the contact list trying to find the next node
  // Avoids a querySelectorAll which would cause performance problems
  function getNextContactNode(contact) {
    var out = contact.nextElementSibling;
    var nextParent = contact.parentNode.parentNode.nextElementSibling;

    while (!out && nextParent) {
      out = nextParent.querySelector('ol > li:first-child');
      nextParent = nextParent.nextElementSibling;
    }

    return out;
  }

  function getClone(node) {
    var id = node.dataset.uuid;
    var out = theClones[id];

    if (!out) {
      out = node.cloneNode();
      cacheClone(id, out);
    }

    return out;
  }

  function cacheClone(id, clone) {
    theClones[id] = clone;
  }

  function onInput(e) {
    if (e.target.id === searchBox.id) {
      search();
    }
  }

  var enterSearchMode = function searchMode(evt) {
    evt.preventDefault();

    if (!inSearchMode) {
      window.addEventListener('input', onInput);
      searchView.classList.add('insearchmode');
      doInit();
      fillInitialSearchPage();
      inSearchMode = true;
      emptySearch = true;

      setTimeout(function nextTick() {
        searchBox.focus();
      });
    }
  };

  function fillInitialSearchPage() {
    hideProgressResults();

    var firstContact = conctactsListView.querySelector(CONTACTS_SELECTOR);
    fillIdentityResults(firstContact, SEARCH_PAGE_SIZE);

    imgLoader.reload();
  }

  function doSearch(contacts, from, searchText, pattern, state) {
    var end = from + CHUNK_SIZE;
    // Check whether the user enter a new term or not
    if (currentTextToSearch.localeCompare(searchText) === 0) {
      for (var c = from; c < end && c < contacts.length; c++) {
        var contact = contacts[c].node || contacts[c];
        var contactText = contacts[c].text || getSearchText(contacts[c]);
        if (!pattern.test(contactText)) {
          if (contact.dataset.uuid in currentSet) {
            searchList.removeChild(currentSet[contact.dataset.uuid]);
            delete currentSet[contact.dataset.uuid];
          }
        } else {
          if (state.count === 0) {
            hideProgressResults();
          }
          // Only an initial page of elements is loaded in the search list
          if (Object.keys(currentSet).length <
              SEARCH_PAGE_SIZE && !(contact.dataset.uuid in currentSet)) {
            var clonedNode = getClone(contact);
            currentSet[contact.dataset.uuid] = clonedNode;
            searchList.appendChild(clonedNode);
          }

          state.searchables.push({
            node: contact,
            text: contactText
          });
          state.count++;
        }
      }
      if (c < contacts.length) {
        window.setTimeout(function do_search() {
          doSearch(contacts, from + CHUNK_SIZE, searchText,
                   pattern, state);
        }, 0);
      } else {
        if (state.count === 0) {
          showNoResults();

          canReuseSearchables = false;
        } else {
          imgLoader.reload();
          searchableNodes = state.searchables;
          canReuseSearchables = true;
          // If the user wished to scroll let's add the remaining results
          if (blurList === true) {
            window.setTimeout(function() {
              addRemainingResults(searchableNodes, SEARCH_PAGE_SIZE);
            },0);
          }
        }

        if (typeof state.searchDoneCb === 'function') {
          state.searchDoneCb();
        }
      }
    }
    else {
      canReuseSearchables = false;
      window.console.warn('**** Cancelling current search ****');
    }
  }

  var enableSearch = function enableSearch() {
    if (searchEnabled) {
      return;
    }

    searchEnabled = true;
    // We perform the search when all the info have been loaded and the
    // user wrote something in the entry field
    if (searchBox.value.trim()) {
      invalidateCache();
      search();
    }
  };

  var search = function performSearch(searchDoneCb) {
    prevTextToSearch = currentTextToSearch;

    currentTextToSearch = utils.text.normalize(searchBox.value.trim());
    currentTextToSearch = utils.text.escapeRegExp(currentTextToSearch);
    var thisSearchText = new String(currentTextToSearch);

    if (thisSearchText.length === 0) {
      resetState();
      window.setTimeout(fillInitialSearchPage, 0);
    }
    else {
      showProgress();
      if (!searchEnabled) {
        resetState();
        return;
      }
      emptySearch = false;
      // The remaining results have not been added yet
      remainingPending = true;
      var pattern = new RegExp(thisSearchText, 'i');
      var contactsToSearch = getContactsToSearch(thisSearchText,
                                               prevTextToSearch);
      var state = {
        count: 0,
        searchables: [],
        searchDoneCb: searchDoneCb
      };
      window.setTimeout(function do_search() {
        doSearch(contactsToSearch, 0, thisSearchText, pattern, state);
      },0);
    }
  };

  function getSearchText(contact) {
    var out = '';

    var uuid = contact.dataset.uuid;
    if (uuid) {
      out = searchTextCache[uuid];
      if (!out) {
        var body = contact.querySelector('[data-search]');
        out = body ? body.dataset['search'] : contact.dataset['search'];
        searchTextCache[uuid] = out;
      }
    }
    else {
      window.console.error('Search: Not uuid found for the provided node');
    }

    return out;
  }

  var getContactsDom = function contactsDom() {
    if (!contactNodes) {
      contactNodes = list.querySelectorAll(CONTACTS_SELECTOR);
    }
    return contactNodes;
  };

  var getContactsToSearch = function getContactsToSearch(newText, prevText) {
    var out;
    if (canReuseSearchables && newText.length > prevText.length &&
        prevText.length > 0 && newText.indexOf(prevText) === 0) {
      out = searchableNodes || getContactsDom();
    } else {
      utils.dom.removeChildNodes(searchList);
      currentSet = {};
      out = getContactsDom();
      canReuseSearchables = false;
    }

    return out;
  };

  var isInSearchMode = function isInSearchMode() {
    return inSearchMode;
  };

  var invalidateCache = function s_invalidate() {
    canReuseSearchables = false;
    searchableNodes = null;
    contactNodes = null;
    currentSet = {};
    searchTextCache = {};
  };

  var removeContact = function s_removeContact(id) {
    var contact = searchList.querySelector('li[data-uuid=\"' + id + '\"]');
    searchList.removeChild(contact);
  };

  function showProgress() {
    searchNoResult.classList.add('hide');
    searchProgress.classList.remove('hidden');
  }

  function showNoResults() {
    searchNoResult.classList.remove('hide');
    searchProgress.classList.add('hidden');
  }

  function hideProgressResults() {
    searchNoResult.classList.add('hide');
    searchProgress.classList.add('hidden');
  }

  return {
    'init': init,
    'invalidateCache': invalidateCache,
    'removeContact': removeContact,
    'search': search,
    'enterSearchMode': enterSearchMode,
    'exitSearchMode': exitSearchMode,
    'isInSearchMode': isInSearchMode,
    'enableSearch': enableSearch,
    // The purpose of this method is only for unit tests
    'load': onLoad
  };
})();</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
